module statix/lang/init

imports
  signatures/Statix2Lang-sig
  signatures/statix/lang/Core-sig
  signatures/statix/lang/Sugar-sig
  signatures/statix/lang/NoParse-sig
  
signature
    sorts
        TERMTYPE LABELTYPE
        
    constructors
       INT      :   TERMTYPE
       STRING   :   TERMTYPE
       LIST     :   TERMTYPE -> TERMTYPE
       SCOPE    :   TERMTYPE
       TUPLE    :   list(TERMTYPE) -> TERMTYPE
       AST_ID   :   TERMTYPE
       PATH     :   TERMTYPE
       SORT     :   string -> TERMTYPE
       LABEL    :   TERMTYPE
       UNIT     :   TERMTYPE
       UNKNOWN  :   TERMTYPE
       
       SIMPLELABEL  : LABELTYPE
       RELATION     : list(TERMTYPE) -> LABELTYPE
       
    relations
        mod         :   string -> scope
        constrain   :   string -> (list(TERMTYPE) * TERMTYPE)
        var         :   string -> TERMTYPE 
        sort        :   string -> TERMTYPE
        construct   :   string -> (list(TERMTYPE) * string)
        label       :   string -> LABELTYPE
        
    name-resolution
        labels P

rules
  resolveConstraint: scope * string -> (list(TERMTYPE) * TERMTYPE)
  resolveConstraint(s, id) = (ATS, RT) :-
    query constrain
        filter P* and {x :- x == id}
        in s |-> [(_,(id,(ATS, RT)))].
        
  declareVariable: scope * string * TERMTYPE
  declareVariable(s, id, T) :-
     !var[id, T] in s.     
  
  resolveVariable: scope * string -> TERMTYPE
  resolveVariable(s, id) = T :-
    query var
        filter P* and {x :- x == id}
        min $ < P and { _, _ :- true }
        in s |-> [(_,(id, T))].
  
  resolveSort: scope * string -> TERMTYPE
  resolveSort(s, id) = T :-
    query sort
        filter P* and {x :- x == id}
        in s |-> [(_,(id, T))].
  
  resolveConstructor: scope * string -> (list(TERMTYPE) * string)
  resolveConstructor(s, id) = (TS, sid) :-
    query construct
        filter P* and {x :- x == id}
        in s |-> [(_,(id,(TS, sid)))].

rules
    unifyTypes: TERMTYPE * TERMTYPE
    unifyTypeList maps unifyTypes(list(*), list(*))
    
    unifyTypes(LIST(T1), LIST(T2)) :-
        unifyTypes(T1, T2).
        
    unifyTypes(TUPLE(TS1), TUPLE(TS2)) :-
        unifyTypeList(TS1, TS2).
    
    unifyTypes(UNKNOWN(), _).
    unifyTypes(_, UNKNOWN()).
    
    unifyTypes(x, x).
    
    unifyTypes(x, y) :-
        false | error $["Cannot unify types [x] and [y]"].
     
rules
  projectOk: scope

  projectOk(_).


  fileOk: scope * Start
  
  fileOk(s, Module2Start(mod)) :-
    moduleOk(s, mod).
    
  fileOk(s, Test2Start(test)) :-
    testOk(s, test).
    
  moduleOk: scope * Module
  
  moduleOk(s, Module(_, sections)) :- {s_mod}
    new s_mod, s_mod -P-> s,
    sectionsOk(s_mod, sections).
  
  testOk: scope * Test
    
  testOk(s, Test(constr, sections)) :- {s_test}
    new s_test, s_test -P-> s,
    sectionsOk(s_test, sections),
    constraintOk(s_test, constr).
      
rules
  sectionOk: scope * Section
  sectionsOk maps sectionOk(*, list(*))
  
  sectionOk(s, Signature(sigs)) :-
    signaturesOk(s, sigs).
  
  sectionOk(s, Rules(rules)) :-
    rulesOk(s, rules).

rules
  signatureOk: scope * Signature
  signaturesOk maps signatureOk(*, list(*))
  
  signatureOk(s, Constraints(decls)) :-
    cDeclsOk(s, decls).
    
  signatureOk(s, Sorts(sdecls)) :-
    sortDeclsOk(s, sdecls).
    
  signatureOk(s, Constructors(opdecls)) :-
    opDeclsOk(s, opdecls).  
      
rules
  sortDeclOk: scope * SortDecl
  sortDeclsOk maps sortDeclOk(*, list(*))
  
  sortDeclOk(s, SortDecl(id)) :-
    !sort[id, SORT(id)] in s.

  sortDeclOk(s, SortAlias(id, sref)) :-
    !sort[id, sortRefToType(s, sref)] in s.
    
  opDeclOk: scope * OpDecl
  opDeclsOk maps opDeclOk(*, list(*))
  
  opDeclOk(s, OpDecl(id, ConstOp(SimpleSort(sid)))) :-
    !construct[id, ([], sid)] in s.
    
  opDeclOk(s, OpDecl(id, ArrowOp(refs, SimpleSort(sid)))) :-
    !construct[id, (sortRefToTypes(s, refs), sid)] in s.
    
rules
  ruleOk: scope * Rule
  rulesOk maps ruleOk(*, list(*))
  
  ruleOk(s, Rule(_, head, cnstrnt)) :- {s_rule}
    new s_rule, s_rule -P-> s,
    ruleHeadOk(s_rule, head),
    constraintOk(s_rule, cnstrnt).
  
  ruleHeadOk: scope * RuleHead
  
  ruleHeadOk(s, C(id, args)) :- {ATS}
    resolveConstraint(s, id) == (ATS, UNIT()),
    paramsOk(s, ATS, args).
    
  ruleHeadOk(s, F(id, args, result)) :- {ATS RT}
    resolveConstraint(s, id) == (ATS, RT),
    paramsOk(s, ATS, args),
    RT == termOk(s, result).
    
  ruleOk(s, CDecl2Rule(cd)) :-
    cDeclOk(s, cd).
  
  //Checking parameters an declaring variables
  paramOk: scope * TERMTYPE * Term
  paramsOk maps paramOk(*, list(*), list(*))
  listparamOk maps paramOk(*, *, list(*))
  
  paramOk(_, _, Var2Term(Wld())).
  paramOk(s, T, Var2Term(Var(var))) :-
    declareVariable(s, var, T).
  
  paramOk(s, T, Tuple(ts)) :- {TS}
    T == TUPLE(TS),
    paramsOk(s, TS, ts).
    
  paramOk(s, T, List(xs)) :- {LT}
    T == LIST(LT),
    listparamOk(s, LT, xs).
    
  paramOk(s, T, ListTail(xs, tail)) :- {LT}
    T == LIST(LT),
    listparamOk(s, LT, xs),
    paramOk(s, T, tail).
  
  paramOk(s, T, Op(id, Terms2CommaTerms(ts))) :- {TS sid}
    (TS, sid) == resolveConstructor(s, id),
    T == resolveSort(s, sid),
    paramsOk(s, TS, ts).
    
  
  paramOk(_, INT(), Int2Term(_)).
  paramOk(_, STRING(), Str2Term(_)).
    
rules
  cDeclOk: scope * CDecl
  cDeclsOk maps cDeclOk(*, list(*))
  
  cDeclOk(s, CDecl(_, id, SimpleType(tys))) :-
    !constrain[id, (sortRefToTypes(s, tys), UNIT())] in s.
  
  cDeclOk(s, CDecl(_, id, FunType(tys, rtty))) :-
    !constrain[id, (sortRefToTypes(s, tys), sortRefToType(s, rtty))] in s.
  
  sortRefToType: scope * SortRef -> TERMTYPE
  sortRefToTypes maps sortRefToType(*, list(*)) = list(*)
  
  sortRefToType(_, IntSort()) = INT().
  sortRefToType(_, StringSort()) = STRING().
  sortRefToType(_, PathSort()) = PATH().
  sortRefToType(_, LabelSort()) = LABEL().
  sortRefToType(_, ScopeSort()) = SCOPE().
  sortRefToType(_, AstIdSort()) = AST_ID().
  
  sortRefToType(s, ListSort(ty)) = LIST(T) :-
    T == sortRefToType(s, ty).
    
  sortRefToType(s, TupleSort(tys)) = TUPLE(TS) :-
    TS == sortRefToTypes(s, tys).  
    
  sortRefToType(s, Sort2SortRef(SimpleSort(sid))) = resolveSort(s, sid).
      
rules
    constraintOk : scope * Constraint

    constraintOk(_, CTrue()).
    
    constraintOk(s, CFalse(m)).

    constraintOk(s, CConj(l, r)) :-
        constraintOk(s, l),
        constraintOk(s, r).
    
    constraintOk(s, CEqual(l, r, m)) :- 
        unifyTypes(termOk(s, l), termOk(s, r)).
    
    constraintOk(s, CArith(e1, _, e2, m)) :-
        arithExpOk(s, e1),
        arithExpOk(s, e2).
        
rules
    termOk : scope * Term -> TERMTYPE
    termsOk maps termOk(*, list(*)) = list(*)
    
    termOk(_, Int2Term(_)) = INT().
    termOk(_, Str2Term(_)) = STRING().
    
    termOk(_, Var2Term(Wld())) = UNKNOWN().
    termOk(s, Var2Term(Var(var))) = resolveVariable(s, var).
    
    termOk(_, List([])) = LIST(UNKNOWN()).
    termOk(s, List(xs)) = LIST(T) :-
        [T|_] == termsOk(s, xs).
    
    termOk(s, ListTail([], tail)) = LIST(T) :-
        LIST(T) == termOk(s, tail).
    termOk(s, ListTail(hs, tail)) = LIST(T) :-
        [T|_] == termsOk(s, hs),
        LIST(T) == termOk(s, tail).
    
    termOk(s, Tuple(t)) = TUPLE(TS) :-
        TS == termsOk(s, t).
    
    termOk(s, Op(id, Terms2CommaTerms(ts))) = T :- {CTS sid}
        (CTS, sid) == resolveConstructor(s, id),
        T == resolveSort(s, sid),
        CTS == termsOk(s, ts).
        
    termOk(s, COp(cid, Terms2CommaTerms(ts))) = RT :- {ATS}
        (ATS, RT) == resolveConstraint(s, cid),
        RT != UNIT() | error "Inline notation can only be used for functional constraints",
        ATS == termsOk(s, ts).
     
    termOk(s, ArithOp(aExp)) = INT() :-
        arithExpOk(s, aExp). 
        
rules
  arithExpOk : scope * ArithExp
  
  arithExpOk(_, Int2ArithExp(_)).
  
  arithExpOk(_, Var2ArithExp(Wld())).
  arithExpOk(s, Var2ArithExp(Var(var))) :- 
    resolveVariable(s, var) == INT().
    
  arithExpOk(s, AAdd(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).
    
  arithExpOk(s, AMul(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).
    
  arithExpOk(s, ASub(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).
    
  arithExpOk(s, AMin(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).
    
  arithExpOk(s, AMax(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).    
    
  arithExpOk(s, AMod(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).
    
  arithExpOk(s, ADiv(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2). 