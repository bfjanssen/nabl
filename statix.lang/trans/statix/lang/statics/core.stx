module statix/lang/statics/core

imports
  signatures/Statix2Lang-sig
  signatures/statix/lang/Core-sig
  signatures/statix/lang/Sugar-sig
  signatures/statix/lang/NoParse-sig
  signatures/statix/lang/Type-sig

signature
  sorts
    LABELTYPE

  constructors
    SIMPLELABEL  : LABELTYPE
    RELATION     : IType -> LABELTYPE

  relations
    mod         :   ModuleId -> scope
    predicate   :   ConstraintId -> IType
    var         :   VARID -> TType
    sort        :   SortId -> TType
    cons        :   OpId * int -> (list(TType) * TType)
    label       :   RelationId -> LABELTYPE

  name-resolution
    labels P

// Working with Relations
rules
  // CONSTRAINTS
  declareConstraint: scope * ConstraintId * IType
  resolveConstraint: scope * ConstraintId -> list((path * (ConstraintId * IType)))
  typeOfConstraint: scope * ConstraintId -> IType

  declareConstraint(s, id, T) :-
    !predicate[id, T] in s,
    resolveConstraint(s, id) == [(_, (_, _))] | error $[Duplicate constraint [id]].

  resolveConstraint(s, id) = ps :-
    query predicate
        filter P* and { x :- x == id }
        in s |-> ps.

  typeOfConstraint(s, id) = T :- {id'}
    resolveConstraint(s, id) == [(_,(id', T))|_] | error $[Constraint [id] not defined].

  // VARIABLES
  declareVariable: scope * VARID
  declareVariables: scope * list(VARID)
  resolveVariable: scope * VARID -> list((path * (VARID * TType)))
  typeOfVariable: scope * VARID -> TType

  declareVariable(s, id) :- {T}
     !var[id, T] in s,
     resolveVariable(s, id) == [(_, (_, _))] | error $[Duplicate variable of type [T]].

  declareVariables(_, []).
  declareVariables(s, [id| xs]) :-
    declareVariable(s, id),
    declareVariables(s, xs).

  resolveVariable(s, id) = ps :-
    query var
        filter P* and { x :- x == id }
        min $ < P
        in s |-> ps.

  typeOfVariable(s, id) = T :- {id'}
    resolveVariable(s, id) == [(_,(id', T))|_] | error $[Variable [id] not defined].

  // SORTS
  declareSort: scope * SortId * TType
  resolveSort: scope * SortId -> list((path * (SortId * TType)))
  typeOfSort: scope * SortId -> TType

  declareSort(s, id, T) :-
    !sort[id, T] in s,
    resolveSort(s, id) == [(_, (_, _))] | error $[Duplicate sort [id]].

  resolveSort(s, id) = ps :-
    query sort
        filter P* and { x :- x == id }
        in s |-> ps.

  typeOfSort(s, id) = T :- {id'}
    resolveSort(s, id) == [(_,(id', T))|_] | error $[Sort [id] not defined].

  // CONSTRUCTORS
  declareCons: scope * OpId * int * (list(TType) * TType)
  resolveCons: scope * OpId * int -> list((path * (OpId * int * (list(TType) * TType))))
  typeOfCons: scope * OpId * int -> (list(TType) * TType)

  declareCons(s, id, arity, T) :-
    !cons[id, arity, T] in s,
    resolveCons(s, id, arity) == [(_, (_, _, _))] | error $[Duplicate constructor [id]/[arity]].

  resolveCons(s, id, arity) = ps :-
    query cons
        filter P* and { (x, y) :- x == id, y == arity }
        in s |-> ps.

  typeOfCons(s, id, arity) = T :- {id' arity'}
    resolveCons(s, id, arity) == [(_, (id', arity', T))|_] | error $[Constructor [id]/[arity] not defined].

// Utility
rules
  sortRefListLength : list(SortRef) -> int

  sortRefListLength([]) = 0.
  sortRefListLength([_|tail]) = #(1 + sum) :-
    sum == sortRefListLength(tail).

  termLength : list(Term) -> int

  termLength([]) = 0.
  termLength([_|tail]) = #(1 + sum) :-
    sum == termLength(tail).

  concat : list(string) * list(string) -> list(string)

  concat([], ys) = ys.
  concat([x|xs],ys) = [x|concat(xs, ys)].

  removeDuplicateVars : list(string) -> list(string)

  removeDuplicateVars([]) = [].
  removeDuplicateVars([x|xs]) = [x|removeDuplicateVars(xs')] :-
    xs' == filterVars(xs, x).

  filterVars : list(string) * string -> list(string)

  filterVars([], _) = [].
  filterVars([id|xs], id) = filterVars(xs, id).
  filterVars([x|xs], f) = [x|filterVars(xs, f)].

  varsToStringList : list(Var) -> list(string)

  varsToStringList([]) = [].
  varsToStringList([Wld()|xs]) = varsToStringList(xs).
  varsToStringList([Var(x)|xs]) = [x|varsToStringList(xs)].

rules
  typeEq: TType * TType
  typeListEq maps typeEq(list(*), list(*))

  typeEq(LIST(T1), LIST(T2)) :-
    typeEq(T1, T2).

  typeEq(TUPLE(TS1), TUPLE(TS2)) :-
    typeListEq(TS1, TS2).

  typeEq(x, x).
  typeEq(x, y) :- false.

rules
  projectOk: scope

  projectOk(_).


  fileOk: scope * Start

  fileOk(s, Module2Start(mod)) :-
    moduleOk(s, mod).

  fileOk(s, Test2Start(test)) :-
    testOk(s, test).

  moduleOk: scope * Module

  moduleOk(s, Module(_, sections)) :- {s_mod}
    new s_mod, s_mod -P-> s,
    sectionsOk(s_mod, sections).

  testOk: scope * Test

  testOk(s, Test(constr, sections)) :- {s_test}
    new s_test, s_test -P-> s,
    sectionsOk(s_test, sections),
    constraintOk(s_test, constr).

rules
  sectionOk: scope * Section
  sectionsOk maps sectionOk(*, list(*))

  sectionOk(s, Signature(sigs)) :-
    signaturesOk(s, sigs).

  sectionOk(s, Rules(rules)) :-
    rulesOk(s, rules).

rules
  signatureOk: scope * Signature
  signaturesOk maps signatureOk(*, list(*))

  signatureOk(s, Constraints(decls)) :-
    cDeclsOk(s, decls).

  signatureOk(s, Sorts(sdecls)) :-
    sortDeclsOk(s, sdecls).

  signatureOk(s, Constructors(opdecls)) :-
    opDeclsOk(s, opdecls).

rules
  sortDeclOk: scope * SortDecl
  sortDeclsOk maps sortDeclOk(*, list(*))

  sortDeclOk(s, SortDecl(id)) :-
    declareSort(s, id, SORT(id)).

  sortDeclOk(s, SortAlias(id, sref)) :-
    declareSort(s, id, sortRefToType(s, sref)).

  opDeclOk: scope * OpDecl
  opDeclsOk maps opDeclOk(*, list(*))

  opDeclOk(s, OpDecl(id, ConstOp(SimpleSort(sid)))) :-
    SORT(sid) == typeOfSort(s,sid),
    declareCons(s, id, 0, ([], SORT(sid))).

  opDeclOk(s, OpDecl(id, ArrowOp(refs, SimpleSort(sid)))) :- {len}
    len == sortRefListLength(refs),
    SORT(sid) == typeOfSort(s, sid),
    declareCons(s, id, len, (sortRefsToTypes(s, refs), SORT(sid))).

rules
  ruleOk: scope * Rule
  rulesOk maps ruleOk(*, list(*))

  ruleOk(s, Rule(_, head, cnstrnt)) :- {s_rule}
    new s_rule, s_rule -P-> s,
    ruleHeadOk(s_rule, head),
    constraintOk(s_rule, cnstrnt).

  ruleHeadOk: scope * RuleHead

  ruleHeadOk(s, a@C(id, args)) :- {TS vars}
    PRED(TS) == typeOfConstraint(s, id),
    vars == removeDuplicateVars(patternsOk(s, TS, args)),
    declareVariables(s, vars),
    @a.type := PRED(TS).

  ruleHeadOk(s, a@F(id, args, result)) :- {ATS RT vs1 vs2 vars}
    FUN(ATS, RT) == typeOfConstraint(s, id),
    vs1 == patternsOk(s, ATS, args),
    vs2 == patternOk(s, RT, result),
    vars == removeDuplicateVars(concat(vs1, vs2)),
    declareVariables(s, vars),
    @a.type := FUN(ATS, RT).

  ruleOk(s, CDecl2Rule(cd)) :-
    cDeclOk(s, cd).

  //Checking patterns and extracting new variables
  patternOk: scope * TType * Term -> list(string)

  patternOk(_, INT(), Int2Term(a@Int(_))) = [] :-
    @a.type := INT().
  patternOk(_, STRING(), Str2Term(a@Str(_))) = [] :-
    @a.type := STRING().

  patternOk(_, T, Var2Term(a@Wld())) = [] :-
    @a.type := T.
  patternOk(s, T, Var2Term(a@Var(var))) = [var] :-
    T == typeOfVariable(s, var),
    @a.type := T.

  patternOk(s, T, a@Tuple(ts)) = vars :- {TS}
    T == TUPLE(TS),
    vars == patternsOk(s, TS, ts),
    @a.type := T.

  patternOk(s, T, a@List(xs)) = vars :- {LT}
    T == LIST(LT),
    vars == listPatternOk(s, LT, xs),
    @a.type := T.

  patternOk(s, T, a@ListTail(xs, tail)) = concat(vs1, vs2) :- {LT}
    T == LIST(LT),
    vs1 == listPatternOk(s, LT, xs),
    vs2 == patternOk(s, T, tail),
    @a.type := T.

  patternOk(s, T, a@Op(id, Terms2CommaTerms(ts))) = vars :- {TS sid len}
    len == termLength(ts),
    (TS, T) == typeOfCons(s, id, len),
    vars == patternsOk(s, TS, ts),
    @a.type := T.

  patternOk(s, T, a@COp(cid, Terms2CommaTerms(ts))) = vars :- {RT ATS}
    FUN(ATS, RT) == typeOfConstraint(s, cid) | error "Inline notation can only be used for functional constraints",
    RT == T,
    vars == patternsOk(s, ATS, ts),
    @a.type := T.

  patternOk(s, T, a@As(v@Wld(), term)) = patternOk(s, T, term) :-
    try { false } | warning "Ascribing to a wildcard is counterintuitive",
    @a.type := T,
    @v.type := T.
  patternOk(s, T, a@As(v@Var(var), term)) = [var|vars] :-
    T == typeOfVariable(s, var),
    vars == patternOk(s, T, term),
    @a.type := T,
    @v.type := T.

  patternOk(s, T, a@Ascribe(term, ty)) = patternOk(s, T, term) :-
    T == sortRefToType(s, ty),
    @a.type := T.

  patternOk(s, T, a@ArithOp(aExp)) = arithPatternOk(s, aExp) :-
    T == INT(),
    @a.type := T.

  arithPatternOk: scope * ArithExp -> list(string)

  arithPatternOk(_, Int2ArithExp(_)) = [].
  arithPatternOk(_, Var2ArithExp(Wld())) = [].
  arithPatternOk(s, Var2ArithExp(Var(var))) = [var] :-
    INT() == typeOfVariable(s, var).

  arithPatternOk(s, AAdd(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, ASub(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMul(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMin(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMax(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, ADiv(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMod(e1, e2)) = concat(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  patternsOk: scope * list(TType) * list(Term) -> list(string)

  patternsOk(_, [], []) = [].
  patternsOk(s, [T|TS], [x|xs]) = concat(vs1, vs2) :-
    vs1 == patternOk(s, T, x),
    vs2 == patternsOk(s, TS, xs).

  listPatternOk: scope * TType * list(Term) -> list(string)

  listPatternOk(_, _, []) = [].
  listPatternOk(s, T, [x|xs]) = concat(vs1, vs2) :-
    vs1 == patternOk(s, T, x),
    vs2 == listPatternOk(s, T, xs).

rules
  cDeclOk: scope * CDecl
  cDeclsOk maps cDeclOk(*, list(*))

  cDeclOk(s, CDecl(_, id, a@SimpleType(tys))) :- {TS}
    TS == sortRefsToTypes(s, tys),
    declareConstraint(s, id, PRED(TS)),
    @a.type := PRED(TS).

  cDeclOk(s, CDecl(_, id, a@FunType(tys, rtty))) :- {TS RT}
    TS == sortRefsToTypes(s, tys),
    RT == sortRefToType(s, rtty),
    declareConstraint(s, id, FUN(TS, RT)),
    @a.type := FUN(TS, RT).

  sortRefToType: scope * SortRef -> TType
  sortRefsToTypes maps sortRefToType(*, list(*)) = list(*)

  sortRefToType(_, a@IntSort()) = INT() :-
    @a.type := INT().
  sortRefToType(_, a@StringSort()) = STRING() :-
    @a.type := STRING().
  sortRefToType(_, a@PathSort()) = PATH() :-
    @a.type := PATH().
  sortRefToType(_, a@LabelSort()) = LABEL() :-
    @a.type := LABEL().
  sortRefToType(_, a@ScopeSort()) = SCOPE() :-
    @a.type := SCOPE().
  sortRefToType(_, a@AstIdSort()) = AST_ID() :-
    @a.type := AST_ID().

  sortRefToType(s, a@ListSort(ty)) = LIST(T) :-
    T == sortRefToType(s, ty),
    @a.type := LIST(T).

  sortRefToType(s, a@TupleSort(tys)) = TUPLE(TS) :-
    TS == sortRefsToTypes(s, tys),
    @a.type := TUPLE(TS).

  sortRefToType(s, Sort2SortRef(a@SimpleSort(sid))) = T :-
    T == typeOfSort(s, sid),
    @a.type := T.

rules
  constraintOk : scope * Constraint

  constraintOk(_, CTrue()).

  constraintOk(s, CFalse(m)) :-
    messageOk(s, m).

  constraintOk(s, CConj(l, r)) :-
    constraintOk(s, l),
    constraintOk(s, r).

  constraintOk(s, CEqual(l, r, m)) :- {T1 T2}
    T1 == termOk(s, l),
    T2 == termOk(s, r),
    T1 == T2 | error $[Cannot unify types [T1] and [T2]],
    messageOk(s, m).

  constraintOk(s, CInequal(l, r, m)) :- {T1 T2}
    T1 == termOk(s, l),
    T2 == termOk(s, r),
    T1 == T2 | error $[Cannot unify types [T1] and [T2]],
    messageOk(s, m).

  constraintOk(s, C(cid, ts, m)) :- {TS}
    PRED(TS) == typeOfConstraint(s, cid) | error "Inline notation can only be used for non-functional constraints",
    TS == termsOk(s, ts),
    messageOk(s, m).

  constraintOk(s, CExists(vars, c)) :- {s_exists}
    new s_exists, s_exists -P-> s,
    declareVariables(s_exists, varsToStringList(vars)),
    constraintOk(s_exists, c).

  constraintOk(s, CArith(e1, _, e2, m)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2),
    messageOk(s, m).

rules
  termOk : scope * Term -> TType
  termsOk maps termOk(*, list(*)) = list(*)
  listTermOk maps termOk(*, list(*)) = *

  termOk(_, Int2Term(a@Int(_))) = INT() :-
    @a.type := INT().
  termOk(_, Str2Term(a@Str(_))) = STRING() :-
    @a.type := STRING().

  termOk(_, Var2Term(Wld())) = _.
  termOk(s, Var2Term(Var(var))) = typeOfVariable(s, var).

  termOk(s, List(xs)) = LIST(T) :-
    T == listTermOk(s, xs).

  termOk(s, ListTail(hs, tail)) = LIST(T) :-
    T == listTermOk(s, hs),
    LIST(T) == termOk(s, tail).

  termOk(s, Tuple(t)) = TUPLE(TS) :-
    TS == termsOk(s, t).

  termOk(s, Op(id, Terms2CommaTerms(ts))) = T :- {CTS sid len}
    len == termLength(ts),
    (CTS, T) == typeOfCons(s, id, len),
    CTS == termsOk(s, ts).

  termOk(s, COp(cid, Terms2CommaTerms(ts))) = RT :- {ATS}
    FUN(ATS, RT) == typeOfConstraint(s, cid) | error "Inline notation can only be used for functional constraints",
    ATS == termsOk(s, ts).

  termOk(s, As(Wld(), term)) = termOk(s, term) :-
    try { false } | warning "Ascribing to a wildcard is counterintuitive".
  termOk(s, As(Var(var), term)) = T :-
    T == typeOfVariable(s, var),
    T == termOk(s, term).

  termOk(s, Ascribe(term, ty)) = T :-
    T == termOk(s, term),
    T == sortRefToType(s, ty).

  termOk(s, ArithOp(aExp)) = INT() :-
    arithExpOk(s, aExp).

rules
  arithExpOk : scope * ArithExp

  arithExpOk(_, Int2ArithExp(_)).

  arithExpOk(_, Var2ArithExp(Wld())).
  arithExpOk(s, Var2ArithExp(Var(var))) :-
    typeOfVariable(s, var) == INT().

  arithExpOk(s, AAdd(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMul(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, ASub(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMin(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMax(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMod(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, ADiv(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

rules
  messageOk : scope * Message

  messageOk(_, NoMessage()).
  messageOk(s, Message(kind, content, origin)) :- {kindString}
    kindString == kindToString(kind),
    kind == Error() | error $[use 'try' for [kindString]],
    messageContentOk(s, content),
    messageOriginOk(s, origin).

  tryMessageOk : scope * Message

  tryMessageOk(_, NoMessage()).
  tryMessageOk(s, Message(_, content, origin)) :-
    messageContentOk(s, content),
    messageOriginOk(s, origin).

  messageContentOk : scope * MessageContent
  messageContentOk(_, NoMessageContent()).
  messageContentOk(_, Str2MessageContent(_)).

  messageContentOk(_, Formatted(parts)).

  messageContentPartOk : scope * MessageContentPart
  messageContentPartsOk maps messageContentPartOk(*, list(*))

  messageContentPartOk(_, Text(_)).
  messageContentPartOk(s, Term(t)) :-
    _ == termOk(s, t).

  messageOriginOk : scope * MessageOrigin
  messageOriginOk(_, NoOrigin()).
  messageOriginOk(_, Origin(Wld())).

  messageOriginOk(s, Origin(Var(var))) :-
    _ == resolveVariable(s, var).

  kindToString : MessageKind -> string

  kindToString(Warning()) = "warnings".
  kindToString(Note()) = "notes".