module statix/lang/statics/core

imports
  signatures/Statix2Lang-sig
  signatures/statix/lang/Core-sig
  signatures/statix/lang/Sugar-sig
  signatures/statix/lang/NoParse-sig
  signatures/statix/lang/Type-sig

signature
  sorts
    LType

  constructors
    EDGE  : LType
    RELATION     : IType -> LType

  relations
    mod         :   ModuleId -> scope
    predicate   :   ConstraintId -> IType
    var         :   VARID -> TType
    sort        :   SortId -> TType
    cons        :   OpId * int -> (list(TType) * TType)
    label       :   RelationId -> LType

  name-resolution
    labels P

// Working with Relations
rules
  // CONSTRAINTS
  declareConstraint: scope * ConstraintId * IType
  resolveConstraint: scope * ConstraintId -> list((path * (ConstraintId * IType)))
  typeOfConstraint: scope * ConstraintId -> IType

  declareConstraint(s, id, T) :-
    !predicate[id, T] in s,
    resolveConstraint(s, id) == [(_, (_, _))] | error $[Duplicate constraint [id]].

  resolveConstraint(s, id) = ps :-
    query predicate
        filter P* and { x :- x == id }
        in s |-> ps.

  typeOfConstraint(s, id) = T :- {id'}
    resolveConstraint(s, id) == [(_,(id', T))|_] | error $[Constraint [id] not defined].

  // VARIABLES
  declareVariable: scope * VARID
  declareVariables maps declareVariable(*, list(*))
  resolveVariable: scope * VARID -> list((path * (VARID * TType)))
  typeOfVariable: scope * VARID -> TType
  typeOfVariables maps typeOfVariable(*, list(*)) = *

  declareVariable(s, id) :- {T}
     !var[id, T] in s,
     resolveVariable(s, id) == [(_, (_, _))] | error $[Duplicate variable of type [T]].

  resolveVariable(s, id) = ps :-
    query var
        filter P* and { x :- x == id }
        min $ < P
        in s |-> ps.

  typeOfVariable(s, id) = T :- {id'}
    resolveVariable(s, id) == [(_,(id', T))|_] | error $[Variable [id] not defined].

  // SORTS
  declareSort: scope * SortId * TType
  resolveSort: scope * SortId -> list((path * (SortId * TType)))
  typeOfSort: scope * SortId -> TType

  declareSort(s, id, T) :-
    !sort[id, T] in s,
    resolveSort(s, id) == [(_, (_, _))] | error $[Duplicate sort [id]].

  resolveSort(s, id) = ps :-
    query sort
        filter P* and { x :- x == id }
        in s |-> ps.

  typeOfSort(s, id) = T :- {id'}
    resolveSort(s, id) == [(_,(id', T))|_] | error $[Sort [id] not defined].

  // CONSTRUCTORS
  declareCons: scope * OpId * int * (list(TType) * TType)
  resolveCons: scope * OpId * int -> list((path * (OpId * int * (list(TType) * TType))))
  typeOfCons: scope * OpId * int -> (list(TType) * TType)

  declareCons(s, id, arity, T) :-
    !cons[id, arity, T] in s,
    resolveCons(s, id, arity) == [(_, (_, _, _))] | error $[Duplicate constructor [id]/[arity]].

  resolveCons(s, id, arity) = ps :-
    query cons
        filter P* and { (x, y) :- x == id, y == arity }
        in s |-> ps.

  typeOfCons(s, id, arity) = T :- {id' arity'}
    resolveCons(s, id, arity) == [(_, (id', arity', T))|_] | error $[Constructor [id]/[arity] not defined].

  // RELATIONS OR LABELS
  declareLabel: scope * RelationId * LType
  resolveLabel: scope * RelationId -> list((path * (RelationId * LType)))
  typeOfLabel: scope * RelationId -> LType

  declareLabel(s, id, T) :-
    !label[id, T] in s,
    resolveLabel(s, id) == [(_, (_, _))] | error $[Duplicate label/relation [id]].

  resolveLabel(s, id) = ps :-
    query label
        filter P* and { x :- x == id }
        in s |-> ps.

  typeOfLabel(s, id) = T :- {id'}
    resolveLabel(s, id) == [(_, (id', T))|_] | error $[Label [id] not defined].

// Utility
rules
  sortRefListLength : list(SortRef) -> int

  sortRefListLength([]) = 0.
  sortRefListLength([_|tail]) = #(1 + sum) :-
    sum == sortRefListLength(tail).

  termLength : list(Term) -> int

  termLength([]) = 0.
  termLength([_|tail]) = #(1 + sum) :-
    sum == termLength(tail).

  concatStringList : list(string) * list(string) -> list(string)

  concatStringList([], ys) = ys.
  concatStringList([x|xs],ys) = [x|concatStringList(xs, ys)].

  concatTTypeList : list(TType) * list(TType) -> list(TType)

  concatTTypeList([], ys) = ys.
  concatTTypeList([x|xs],ys) = [x|concatTTypeList(xs, ys)].

  removeDuplicateVars : list(string) -> list(string)

  removeDuplicateVars([]) = [].
  removeDuplicateVars([x|xs]) = [x|removeDuplicateVars(xs')] :-
    xs' == filterVars(xs, x).

  filterVars : list(string) * string -> list(string)

  filterVars([], _) = [].
  filterVars([id|xs], id) = filterVars(xs, id).
  filterVars([x|xs], f) = [x|filterVars(xs, f)].

  varsToStringList : list(Var) -> list(string)

  varsToStringList([]) = [].
  varsToStringList([Wld()|xs]) = varsToStringList(xs).
  varsToStringList([Var(x)|xs]) = [x|varsToStringList(xs)].

  inType: IType -> TType

  inType(PRED(TS)) = typesToType(TS).
  inType(FUN(TS, _)) = typesToType(TS).

  inOutType: IType -> TType

  inOutType(PRED(TS)) = typesToType(TS).
  inOutType(FUN(TS, RT)) = typesToType(concatTTypeList(TS, [RT])).

  typesToType: list(TType) -> TType

  typesToType([ty]) = ty.
  typesToType(TS) = TUPLE(TS).

rules
  typeEq: TType * TType
  typeListEq maps typeEq(list(*), list(*))

  typeEq(LIST(T1), LIST(T2)) :-
    typeEq(T1, T2).

  typeEq(TUPLE(TS1), TUPLE(TS2)) :-
    typeListEq(TS1, TS2).

  typeEq(x, x).
  typeEq(x, y) :- false.

rules
  projectOk: scope

  projectOk(_).


  fileOk: scope * Start

  fileOk(s, Module2Start(mod)) :-
    moduleOk(s, mod).

  fileOk(s, Test2Start(test)) :-
    testOk(s, test).

  moduleOk: scope * Module

  moduleOk(s, Module(_, sections)) :- {s_mod}
    new s_mod, s_mod -P-> s,
    sectionsOk(s_mod, sections).

  testOk: scope * Test

  testOk(s, Test(constr, sections)) :- {s_test}
    new s_test, s_test -P-> s,
    sectionsOk(s_test, sections),
    constraintOk(s_test, constr).

rules
  sectionOk: scope * Section
  sectionsOk maps sectionOk(*, list(*))

  sectionOk(s, Signature(sigs)) :-
    signaturesOk(s, sigs).

  sectionOk(s, Rules(rules)) :-
    rulesOk(s, rules).

rules
  signatureOk: scope * Signature
  signaturesOk maps signatureOk(*, list(*))

  signatureOk(s, Constraints(decls)) :-
    cDeclsOk(s, decls).

  signatureOk(s, Relations(decls)) :-
    relDeclsOk(s, decls).

  signatureOk(s, NameResolution(ls)) :-
    resolutionParamsOk(s, ls).

  signatureOk(s, Sorts(sdecls)) :-
    sortDeclsOk(s, sdecls).

  signatureOk(s, Constructors(opdecls)) :-
    opDeclsOk(s, opdecls).

rules
  sortDeclOk: scope * SortDecl
  sortDeclsOk maps sortDeclOk(*, list(*))

  sortDeclOk(s, SortDecl(id)) :-
    declareSort(s, id, SORT(id)).

  sortDeclOk(s, SortAlias(id, sref)) :-
    declareSort(s, id, sortRefToType(s, sref)).

  opDeclOk: scope * OpDecl
  opDeclsOk maps opDeclOk(*, list(*))

  opDeclOk(s, OpDecl(id, ConstOp(SimpleSort(sid)))) :-
    SORT(sid) == typeOfSort(s,sid),
    declareCons(s, id, 0, ([], SORT(sid))).

  opDeclOk(s, OpDecl(id, ArrowOp(refs, SimpleSort(sid)))) :- {len}
    len == sortRefListLength(refs),
    SORT(sid) == typeOfSort(s, sid),
    declareCons(s, id, len, (sortRefsToTypes(s, refs), SORT(sid))).

rules
  ruleOk: scope * Rule
  rulesOk maps ruleOk(*, list(*))

  ruleOk(s, Rule(_, head, cnstrnt)) :- {s_rule}
    new s_rule, s_rule -P-> s,
    ruleHeadOk(s_rule, head),
    constraintOk(s_rule, cnstrnt).

  ruleHeadOk: scope * RuleHead

  ruleHeadOk(s, a@C(id, args)) :- {TS vars}
    PRED(TS) == typeOfConstraint(s, id),
    vars == removeDuplicateVars(patternsOk(s, TS, args)),
    declareVariables(s, vars),
    @a.type := PRED(TS).

  ruleHeadOk(s, a@F(id, args, result)) :- {ATS RT vs1 vs2 vars}
    FUN(ATS, RT) == typeOfConstraint(s, id),
    vs1 == patternsOk(s, ATS, args),
    vs2 == patternOk(s, RT, result),
    vars == removeDuplicateVars(concatStringList(vs1, vs2)),
    declareVariables(s, vars),
    @a.type := FUN(ATS, RT).

  ruleOk(s, CDecl2Rule(cd)) :-
    cDeclOk(s, cd).

  ruleOk(s, RelDecl2Rule(rd)) :-
    relDeclOk(s, rd).

  //Checking patterns and extracting new variables
  patternOk: scope * TType * Term -> list(string)

  patternOk(_, INT(), Int2Term(a@Int(_))) = [] :-
    @a.type := INT().
  patternOk(_, STRING(), Str2Term(a@Str(_))) = [] :-
    @a.type := STRING().

  patternOk(_, T, Var2Term(a@Wld())) = [] :-
    @a.type := T.
  patternOk(s, T, Var2Term(a@Var(var))) = [var] :-
    T == typeOfVariable(s, var),
    @a.type := T.

  patternOk(s, T, a@Tuple(ts)) = vars :- {TS}
    T == TUPLE(TS),
    vars == patternsOk(s, TS, ts),
    @a.type := T.

  patternOk(s, T, a@List(xs)) = vars :- {LT}
    T == LIST(LT),
    vars == listPatternOk(s, LT, xs),
    @a.type := T.

  patternOk(s, T, a@ListTail(xs, tail)) = concatStringList(vs1, vs2) :- {LT}
    T == LIST(LT),
    vs1 == listPatternOk(s, LT, xs),
    vs2 == patternOk(s, T, tail),
    @a.type := T.

  patternOk(s, T, a@Op(id, Terms2CommaTerms(ts))) = vars :- {TS sid len}
    len == termLength(ts),
    (TS, T) == typeOfCons(s, id, len),
    vars == patternsOk(s, TS, ts),
    @a.type := T.

  patternOk(s, T, a@COp(cid, Terms2CommaTerms(ts))) = vars :- {RT ATS}
    FUN(ATS, RT) == typeOfConstraint(s, cid) | error "Inline notation can only be used for functional constraints",
    RT == T,
    vars == patternsOk(s, ATS, ts),
    @a.type := T.

  patternOk(s, T, a@As(v@Wld(), term)) = patternOk(s, T, term) :-
    try { false } | warning "Ascribing to a wildcard is counterintuitive",
    @a.type := T,
    @v.type := T.
  patternOk(s, T, a@As(v@Var(var), term)) = [var|vars] :-
    T == typeOfVariable(s, var),
    vars == patternOk(s, T, term),
    @a.type := T,
    @v.type := T.

  patternOk(s, T, a@Ascribe(term, ty)) = patternOk(s, T, term) :-
    T == sortRefToType(s, ty),
    @a.type := T.

  patternOk(s, SCOPE(), a@NewOp()) = [] :-
    @a.type := SCOPE().

  patternOk(s, AST_ID(), a@AstIdOp(t)) = patternOk(s, _, t) :-
    @a.type := AST_ID().

  patternOk(s, PATH(), Path2Term(PathLit2Path(a@PathEmpty(st)))) = vars :-
    vars == patternOk(s, SCOPE(), st),
    @a.type := PATH().

  patternOk(s, PATH(), Path2Term(PathLit2Path(a@PathStep(pt, lt, st)))) = vars :- {vs1 vs2 vs3}
    vs1 == patternOk(s, PATH(), pt),
    vs2 == patternOk(s, LABEL(), lt),
    vs3 == patternOk(s, SCOPE(), st),
    vars == concatStringList(vs1, concatStringList(vs2, vs3)),
    @a.type := PATH().

  patternOk(s, T, a@ArithOp(aExp)) = arithPatternOk(s, aExp) :-
    T == INT(),
    @a.type := T.

  arithPatternOk: scope * ArithExp -> list(string)

  arithPatternOk(_, Int2ArithExp(_)) = [].
  arithPatternOk(_, Var2ArithExp(Wld())) = [].
  arithPatternOk(s, Var2ArithExp(Var(var))) = [var] :-
    INT() == typeOfVariable(s, var).

  arithPatternOk(s, AAdd(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, ASub(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMul(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMin(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMax(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, ADiv(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  arithPatternOk(s, AMod(e1, e2)) = concatStringList(vs1, vs2) :-
    vs1 == arithPatternOk(s, e1),
    vs2 == arithPatternOk(s, e2).

  patternsOk: scope * list(TType) * list(Term) -> list(string)

  patternsOk(_, [], []) = [].
  patternsOk(s, [T|TS], [x|xs]) = concatStringList(vs1, vs2) :-
    vs1 == patternOk(s, T, x),
    vs2 == patternsOk(s, TS, xs).

  listPatternOk: scope * TType * list(Term) -> list(string)

  listPatternOk(_, _, []) = [].
  listPatternOk(s, T, [x|xs]) = concatStringList(vs1, vs2) :-
    vs1 == patternOk(s, T, x),
    vs2 == listPatternOk(s, T, xs).

rules
  cDeclOk: scope * CDecl
  cDeclsOk maps cDeclOk(*, list(*))

  cDeclOk(s, CDecl(_, id, a@SimpleType(tys))) :- {TS}
    TS == sortRefsToTypes(s, tys),
    declareConstraint(s, id, PRED(TS)),
    @a.type := PRED(TS).

  cDeclOk(s, CDecl(_, id, a@FunType(tys, rtty))) :- {TS RT}
    TS == sortRefsToTypes(s, tys),
    RT == sortRefToType(s, rtty),
    declareConstraint(s, id, FUN(TS, RT)),
    @a.type := FUN(TS, RT).

  sortRefToType: scope * SortRef -> TType
  sortRefsToTypes maps sortRefToType(*, list(*)) = list(*)

  sortRefToType(_, a@IntSort()) = INT() :-
    @a.type := INT().
  sortRefToType(_, a@StringSort()) = STRING() :-
    @a.type := STRING().
  sortRefToType(_, a@PathSort()) = PATH() :-
    @a.type := PATH().
  sortRefToType(_, a@LabelSort()) = LABEL() :-
    @a.type := LABEL().
  sortRefToType(_, a@ScopeSort()) = SCOPE() :-
    @a.type := SCOPE().
  sortRefToType(_, a@AstIdSort()) = AST_ID() :-
    @a.type := AST_ID().

  sortRefToType(s, a@ListSort(ty)) = LIST(T) :-
    T == sortRefToType(s, ty),
    @a.type := LIST(T).

  sortRefToType(s, a@TupleSort(tys)) = TUPLE(TS) :-
    TS == sortRefsToTypes(s, tys),
    @a.type := TUPLE(TS).

  sortRefToType(s, Sort2SortRef(a@SimpleSort(sid))) = T :-
    T == typeOfSort(s, sid),
    @a.type := T.

rules
  relDeclOk: scope * RelDecl
  relDeclsOk maps relDeclOk(*, list(*))

  relDeclOk(s, RelDecl(Label(rel), a@SimpleType(tys))) :- {TS}
    TS == sortRefsToTypes(s, tys),
    declareLabel(s, rel, RELATION(PRED(TS))),
    @a.type := PRED(TS).

  relDeclOk(s, RelDecl(Label(rel), a@FunType(tys, rty))) :- {TS RT}
    TS == sortRefsToTypes(s, tys),
    RT == sortRefToType(s, rty),
    declareLabel(s, rel, RELATION(FUN(TS, RT))),
    @a.type := FUN(TS, RT).

  resolutionParamsOk maps declareLabels(*, list(*))
  declareLabels: scope * ResolutionParam

  declareLabels(s, Labels([])).
  declareLabels(s, Labels([Label(l)|xs])) :-
    declareLabel(s, l, EDGE()),
    declareLabels(s, Labels(xs)).

  edgeRefOk: scope * EdgeRef

  edgeRefOk(_, TGT()).
  edgeRefOk(s, Label2EdgeRef(Label(l))) :-
    EDGE() == typeOfLabel(s, l).

  labelPairOk: scope * LabelPair
  labelPairsOk maps labelPairOk(*, list(*))

  labelPairOk(s, LabelPair(l1, l2)) :-
    edgeRefOk(s, l1),
    edgeRefOk(s, l2).

  labelOrdOk: scope * LabelOrd
  labelOrdOk(s, LabelPairs2LabelOrd(LabelPairs2LabelPairs(ls))) :-
    labelPairsOk(s, ls).

  labelRegExOk: scope * LabelRE

  labelRegExOk(_, Empty()).
  labelRegExOk(_, Epsilon()).

  labelRegExOk(s, Label2LabelRE(Label(l))) :-
    EDGE() == typeOfLabel(s, l).

  labelRegExOk(s, Closure(lre)) :-
    labelRegExOk(s, lre).

  labelRegExOk(s, Neg(lre)) :-
    labelRegExOk(s, lre).

  labelRegExOk(s, Concat(lre1, lre2)) :-
    labelRegExOk(s, lre1),
    labelRegExOk(s, lre2).

  labelRegExOk(s, And(lre1, lre2)) :-
    labelRegExOk(s, lre1),
    labelRegExOk(s, lre2).

  labelRegExOk(s, Or(lre1, lre2)) :-
    labelRegExOk(s, lre1),
    labelRegExOk(s, lre2).

  hoConstraintOk: scope * HoConstraint * list(TType)

  hoConstraintOk(_, a@LTrue(), TS) :-
    @a.type := PRED(TS).
  hoConstraintOk(_, a@LFalse(), TS) :-
    @a.type := PRED(TS).

  hoConstraintOk(s, a@LLam(args, cnstrnt), TS) :- {s_hc vars}
    new s_hc, s_hc -P-> s,
    vars == removeDuplicateVars(patternsOk(s_hc, TS, args)),
    declareVariables(s_hc, vars),
    constraintOk(s_hc, cnstrnt),
    @a.type := PRED(TS).

  hoConstraintOk(s, a@LC(cid), TS) :-
    PRED(TS) == typeOfConstraint(s, cid),
    @a.type := PRED(TS).

  hoConstraintOk(s, a@EQ(t), [T]) :-
    T == termOk(s, t),
    @a.type := PRED([T]).

rules
  constraintOk : scope * Constraint

  constraintOk(_, CTrue()).

  constraintOk(s, CFalse(m)) :-
    messageOk(s, m).

  constraintOk(s, CConj(l, r)) :-
    constraintOk(s, l),
    constraintOk(s, r).

  constraintOk(s, CNew(vars)) :-
    SCOPE() == typeOfVariables(s, varsToStringList(vars)).

  constraintOk(s, CTellEdge(t1, Label(l), t2)) :-
    SCOPE() == termOk(s, t1),
    EDGE() == typeOfLabel(s, l),
    SCOPE() == termOk(s, t2).

  constraintOk(s, CEqual(l, r, m)) :- {T1 T2}
    T1 == termOk(s, l),
    T2 == termOk(s, r),
    T1 == T2 | error $[Cannot unify types [T1] and [T2]],
    messageOk(s, m).

  constraintOk(s, CInequal(l, r, m)) :- {T1 T2}
    T1 == termOk(s, l),
    T2 == termOk(s, r),
    T1 == T2 | error $[Cannot unify types [T1] and [T2]],
    messageOk(s, m).

  constraintOk(s, C(cid, ts, m)) :- {TS}
    PRED(TS) == typeOfConstraint(s, cid) | error "Inline notation can only be used for non-functional constraints",
    TS == termsOk(s, ts),
    messageOk(s, m).

  constraintOk(s, CExists(vars, c)) :- {s_exists}
    new s_exists, s_exists -P-> s,
    declareVariables(s_exists, varsToStringList(vars)),
    constraintOk(s_exists, c).

  constraintOk(s, CAstId(t1, t2)) :-
    _ == termOk(s, t1),
    AST_ID() == termOk(s, t2).

  constraintOk(s, CAstProperty(Var2TermOrTermIndex(Wld()), _, _, t)) :-
    try { false } | warning "Assigning property to wildcard is counterintuitive",
    _ == termOk(s, t).
  constraintOk(s, CAstProperty(Var2TermOrTermIndex(Var(var)), _, _, t)) :-
    _ == typeOfVariable(s, var),
    _ == termOk(s, t).

  constraintOk(s, CTellRel(Label2RelRef(Label(rid)), Terms2CommaTerms(ts), st)) :- {T}
    RELATION(T) == typeOfLabel(s, rid),
    relationTypesMatch(T, termsOk(s, ts)),
    SCOPE() == termOk(s, st).

  relationTypesMatch: IType * list(TType)

  relationTypesMatch(PRED(TS), TS).
  relationTypesMatch(FUN(ATS, RT), TS) :-
    TS == concatTTypeList(ATS, [RT]).

  constraintOk(s, CResolveQuery(tgt, fltr, qmin, st, result, m)) :- {T}
    T == queryTargetToType(s, tgt),
    filterOk(s, fltr, inType(T)),
    minOk(s, qmin, inType(T)),
    SCOPE() == termOk(s, st),
    LIST(TUPLE([PATH(), inOutType(T)])) == termOk(s, result),
    messageOk(s, m).

  queryTargetToType: scope * QueryTarget -> IType

  queryTargetToType(_, a@EOP()) = PRED([SCOPE()]) :-
    @a.type := PRED([SCOPE()]).
  queryTargetToType(s, RelRef2QueryTarget(Label2RelRef(a@Label(l)))) = T :-
    RELATION(T) == typeOfLabel(s, l),
    @a.type := T.

  filterOk: scope * QueryFilter * TType

  filterOk(s, Filter(lre, hc), T) :-
    labelRegExOk(s, lre),
    hoConstraintOk(s, hc, [T]).

  minOk: scope * QueryMin * TType

  minOk(s, Min(ord, hc), T) :-
    labelOrdOk(s, ord),
    hoConstraintOk(s, hc, [T, T]).

  constraintOk(s, CArith(e1, _, e2, m)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2),
    messageOk(s, m).

rules
  termOk : scope * Term -> TType
  termsOk maps termOk(*, list(*)) = list(*)
  listTermOk maps termOk(*, list(*)) = *

  termOk(_, Int2Term(a@Int(_))) = INT() :-
    @a.type := INT().
  termOk(_, Str2Term(a@Str(_))) = STRING() :-
    @a.type := STRING().

  termOk(_, Var2Term(Wld())) = _.
  termOk(s, Var2Term(Var(var))) = typeOfVariable(s, var).

  termOk(s, List(xs)) = LIST(T) :-
    T == listTermOk(s, xs).

  termOk(s, ListTail(hs, tail)) = LIST(T) :-
    T == listTermOk(s, hs),
    LIST(T) == termOk(s, tail).

  termOk(s, Tuple(t)) = TUPLE(TS) :-
    TS == termsOk(s, t).

  termOk(s, Op(id, Terms2CommaTerms(ts))) = T :- {CTS sid len}
    len == termLength(ts),
    (CTS, T) == typeOfCons(s, id, len),
    CTS == termsOk(s, ts).

  termOk(s, COp(cid, Terms2CommaTerms(ts))) = RT :- {ATS}
    FUN(ATS, RT) == typeOfConstraint(s, cid) | error "Inline notation can only be used for functional constraints",
    ATS == termsOk(s, ts).

  termOk(s, As(Wld(), term)) = termOk(s, term) :-
    try { false } | warning "Ascribing to a wildcard is counterintuitive".
  termOk(s, As(Var(var), term)) = T :-
    T == typeOfVariable(s, var),
    T == termOk(s, term).

  termOk(s, Ascribe(term, ty)) = T :-
    T == termOk(s, term),
    T == sortRefToType(s, ty).

  termOk(_, NewOp()) = SCOPE().

  termOk(s, AstIdOp(t)) = AST_ID() :-
    _ == termOk(s, t).

  termOk(s, Path2Term(PathLit2Path(PathEmpty(st)))) = PATH() :-
    SCOPE() == termOk(s, st).

  termOk(s, Path2Term(PathLit2Path(PathStep(pt, lt, st)))) = PATH() :-
    PATH() == termOk(s, pt),
    LABEL() == termOk(s, lt),
    SCOPE() == termOk(s, st).

  termOk(s, ArithOp(aExp)) = INT() :-
    arithExpOk(s, aExp).

rules
  arithExpOk : scope * ArithExp

  arithExpOk(_, Int2ArithExp(_)).

  arithExpOk(_, Var2ArithExp(Wld())).
  arithExpOk(s, Var2ArithExp(Var(var))) :-
    typeOfVariable(s, var) == INT().

  arithExpOk(s, AAdd(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMul(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, ASub(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMin(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMax(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, AMod(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

  arithExpOk(s, ADiv(e1, e2)) :-
    arithExpOk(s, e1),
    arithExpOk(s, e2).

rules
  messageOk : scope * Message

  messageOk(_, NoMessage()).
  messageOk(s, Message(kind, content, origin)) :- {kindString}
    kindString == kindToString(kind),
    kind == Error() | error $[use 'try' for [kindString]],
    messageContentOk(s, content),
    messageOriginOk(s, origin).

  tryMessageOk : scope * Message

  tryMessageOk(_, NoMessage()).
  tryMessageOk(s, Message(_, content, origin)) :-
    messageContentOk(s, content),
    messageOriginOk(s, origin).

  messageContentOk : scope * MessageContent
  messageContentOk(_, NoMessageContent()).
  messageContentOk(_, Str2MessageContent(_)).

  messageContentOk(_, Formatted(parts)).

  messageContentPartOk : scope * MessageContentPart
  messageContentPartsOk maps messageContentPartOk(*, list(*))

  messageContentPartOk(_, Text(_)).
  messageContentPartOk(s, Term(t)) :-
    _ == termOk(s, t).

  messageOriginOk : scope * MessageOrigin
  messageOriginOk(_, NoOrigin()).
  messageOriginOk(_, Origin(Wld())).

  messageOriginOk(s, Origin(Var(var))) :-
    _ == resolveVariable(s, var).

  kindToString : MessageKind -> string

  kindToString(Warning()) = "warnings".
  kindToString(Note()) = "notes".