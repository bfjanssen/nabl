module statix/lang/statics/util

imports
  signatures/statix/lang/Core-sig
  signatures/statix/lang/Type-sig

signature
  sorts
    LType
    CKind

  constructors
    EDGE        : LType
    RELATION    : IType -> LType

    DeclaredC : CKind
    DerivedC  : CKind

  relations
    mod         :   ModuleId -> scope
    predicate   :   ConstraintId -> IType
    var         :   VARID -> TType
    sort        :   SortId -> TType
    cons        :   OpId * int -> (list(TType) * TType)
    label       :   RelationId -> LType

    cKind        :   ConstraintId -> CKind

  name-resolution
    labels P I

// Working with Relations
rules
  // MODULES
  declareModule: scope * ModuleId * scope
  resolveModule: scope * ModuleId -> list((path * (ModuleId * scope)))
  scopeOfModule: scope * ModuleId -> scope

  declareModule(s, id, s_mod) :-
    !mod[id, s_mod] in s,
    resolveModule(s, id) == [(_, (_, _))] | error $[Duplicate module [id]].

  resolveModule(s, id) = ps :-
    query mod
      filter P* and { x :- x == id }
      in s |-> ps.

  scopeOfModule(s, id) = s_mod :- {id'}
    resolveModule(s, id) == [(_,(id', s_mod))|_] | error $[Unresolved import module [id]].

  // CONSTRAINTS
  declareConstraint: scope * ConstraintId * IType
  resolveConstraint: scope * ConstraintId -> list((path * (ConstraintId * IType)))
  typeOfConstraint: scope * ConstraintId -> IType
  duplicateImportedConstraints: scope * scope

  declareConstraint(s, id, T) :-
    !predicate[id, T] in s,
    query predicate
        filter e and { x :- x == id }
        in s |-> [(_, (_, _))] | error $[Duplicate constraint [id]],
    try { query predicate
            filter I+ and { x :- x == id }
            in s |-> []
    } | warning $[Shadowing imported constraint [id]].

  resolveConstraint(s, id) = ps :-
    query predicate
        filter P*I* and { x :- x == id }
        in s |-> ps.

  typeOfConstraint(s, id) = T :- {id'}
    resolveConstraint(s, id) == [(_,(id', T))|_] | error $[Constraint [id] not defined].

  duplicateImportedConstraints(s, s_import) :- {ps}
    query predicate
        filter I*
        in s_import |-> ps,
    areUniqueImportedConstraints(s, ps).

  isUniqueImportedConstraint: scope * (path * (ConstraintId * IType))
  areUniqueImportedConstraints maps isUniqueImportedConstraint(*, list(*))

  isUniqueImportedConstraint(s, (_, (id, _))) :-
    query predicate
        filter I+ and { x :- x == id }
        in s |-> [(_, (_, _))] | error $[Duplicate imported constraint [id]].

  // VARIABLES
  declareVariable: scope * VARID
  declareVariables maps declareVariable(*, list(*))
  resolveVariable: scope * VARID -> list((path * (VARID * TType)))
  typeOfVariable: scope * VARID -> TType
  typeOfVariables maps typeOfVariable(*, list(*)) = *

  declareVariable(s, id) :- {T}
     !var[id, T] in s,
     query var
        filter e and { x :- x == id }
        in s |-> [(_, (_, _))] | error $[Duplicate variable [id]],
    try { query var
            filter P+ and { x :- x == id }
            in s |-> []
    } | warning $[Shadowing variable [id]].

  resolveVariable(s, id) = ps :-
    query var
        filter P* and { x :- x == id }
        min $ < P
        in s |-> ps.

  typeOfVariable(s, id) = T :- {id'}
    resolveVariable(s, id) == [(_,(id', T))|_] | error $[Variable [id] not defined].

  // SORTS
  declareSort: scope * SortId * TType
  resolveSort: scope * SortId -> list((path * (SortId * TType)))
  typeOfSort: scope * SortId -> TType
  duplicateImportedSorts: scope * scope

  declareSort(s, id, T) :-
    !sort[id, T] in s,
    resolveSort(s, id) == [(_, (_, _))] | error $[Duplicate sort [id]].

  resolveSort(s, id) = ps :-
    query sort
        filter P*I* and { x :- x == id }
        in s |-> ps.

  typeOfSort(s, id) = T :- {id'}
    resolveSort(s, id) == [(_,(id', T))|_] | error $[Sort [id] not defined].

  duplicateImportedSorts(s, s_import) :- {ps}
    query sort
        filter I*
        in s_import |-> ps,
    areUniqueImportedSorts(s, ps).

  isUniqueImportedSort: scope * (path * (SortId * TType))
  areUniqueImportedSorts maps isUniqueImportedSort(*, list(*))

  isUniqueImportedSort(s, (_, (id, _))) :-
    query sort
        filter I+ and { x :- x == id }
        in s |-> [(_, (_, _))] | error $[Duplicate imported sort [id]].

  // CONSTRUCTORS
  declareCons: scope * OpId * int * (list(TType) * TType)
  resolveCons: scope * OpId * int -> list((path * (OpId * int * (list(TType) * TType))))
  typeOfCons: scope * OpId * int -> (list(TType) * TType)
  duplicateImportedCons: scope * scope

  declareCons(s, id, arity, T) :-
    !cons[id, arity, T] in s,
    resolveCons(s, id, arity) == [(_, (_, _, _))] | error $[Duplicate constructor [id]/[arity]].

  resolveCons(s, id, arity) = ps :-
    query cons
        filter P*I* and { (x, y) :- x == id, y == arity }
        in s |-> ps.

  typeOfCons(s, id, arity) = T :- {id' arity'}
    resolveCons(s, id, arity) == [(_, (id', arity', T))|_] | error $[Constructor [id]/[arity] not defined].

  duplicateImportedCons(s, s_import) :- {ps}
    query cons
        filter I*
        in s_import |-> ps,
    areUniqueImportedCons(s, ps).

  isUniqueImportedCons: scope * (path * (OpId * int * (list(TType) * TType)))
  areUniqueImportedCons maps isUniqueImportedCons(*, list(*))

  isUniqueImportedCons(s, (_, (id, arity, _))) :-
    query cons
        filter I+ and { (x, y) :- x == id, y == arity }
        in s |-> [(_, (_, _, _))] | error $[Duplicate imported constructor [id]/[arity]].

  // RELATIONS OR LABELS
  declareLabel: scope * RelationId * LType
  resolveLabel: scope * RelationId -> list((path * (RelationId * LType)))
  typeOfLabel: scope * RelationId -> LType
  duplicateImportedLabels: scope * scope

  declareLabel(s, id, T) :-
    !label[id, T] in s,
    query label
        filter e and { x :- x == id }
        in s |-> [(_, (_, _))] | error $[Duplicate label/relation [id]],
    try { query label
            filter I and { x :- x == id }
            in s |-> []
    } | warning $[Shadowing imported label/relation [id]].

  resolveLabel(s, id) = ps :-
    query label
        filter P*I? and { x :- x == id }
        in s |-> ps.

  typeOfLabel(s, id) = T :- {id'}
    resolveLabel(s, id) == [(_, (id', T))|_] | error $[Label [id] not defined].

  duplicateImportedLabels(s, s_import) :- {ps}
    query label
        filter e
        in s_import |-> ps,
    areUniqueImportedLabels(s, ps).

  isUniqueImportedLabel: scope * (path * (RelationId * LType))
  areUniqueImportedLabels maps isUniqueImportedLabel(*, list(*))

  isUniqueImportedLabel(s, (_, (id, _))) :-
    query label
        filter I and { x :- x == id }
        in s |-> [(_, (_, _))] | error $[Duplicate imported label/relation [id]].

  // KIND OF CONSTRAINTS
  setCKind: scope * ConstraintId * CKind
  resolveCKind: scope * ConstraintId -> list((path * (ConstraintId * CKind)))
  getCKind: scope * ConstraintId -> CKind

  setCKind(s, id, kind) :-
    !cKind[id, kind] in s.

  resolveCKind(s, id) = ps :-
    query cKind
        filter P*I* and { x :- x == id }
        in s |-> ps.

  getCKind(s, id) = kind :- {id'}
    resolveCKind(s, id) == [(_, (id', kind))|_].

// Utility
rules
  sortRefListLength : list(SortRef) -> int

  sortRefListLength([]) = 0.
  sortRefListLength([_|tail]) = #(1 + sum) :-
    sum == sortRefListLength(tail).

  termLength : list(Term) -> int

  termLength([]) = 0.
  termLength([_|tail]) = #(1 + sum) :-
    sum == termLength(tail).

  concatStringList : list(string) * list(string) -> list(string)

  concatStringList([], ys) = ys.
  concatStringList([x|xs],ys) = [x|concatStringList(xs, ys)].

  concatTTypeList : list(TType) * list(TType) -> list(TType)

  concatTTypeList([], ys) = ys.
  concatTTypeList([x|xs],ys) = [x|concatTTypeList(xs, ys)].

  removeDuplicateVars : list(string) -> list(string)

  removeDuplicateVars([]) = [].
  removeDuplicateVars([x|xs]) = [x|removeDuplicateVars(xs')] :-
    xs' == filterVars(xs, x).

  filterVars : list(string) * string -> list(string)

  filterVars([], _) = [].
  filterVars([id|xs], id) = filterVars(xs, id).
  filterVars([x|xs], f) = [x|filterVars(xs, f)].

  varsToStringList : list(Var) -> list(string)

  varsToStringList([]) = [].
  varsToStringList([Wld()|xs]) = varsToStringList(xs).
  varsToStringList([Var(x)|xs]) = [x|varsToStringList(xs)].

  inType: IType -> TType

  inType(PRED(TS)) = typesToType(TS).
  inType(FUN(TS, _)) = typesToType(TS).

  inOutType: IType -> TType

  inOutType(PRED(TS)) = typesToType(TS).
  inOutType(FUN(TS, RT)) = typesToType(concatTTypeList(TS, [RT])).

  typesToType: list(TType) -> TType

  typesToType([ty]) = ty.
  typesToType(TS) = TUPLE(TS).

rules
  typeEq: TType * TType
  typeListEq maps typeEq(list(*), list(*))

  typeEq(LIST(T1), LIST(T2)) :-
    typeEq(T1, T2).

  typeEq(TUPLE(TS1), TUPLE(TS2)) :-
    typeListEq(TS1, TS2).

  typeEq(x, x).
  typeEq(x, y) :- false.
